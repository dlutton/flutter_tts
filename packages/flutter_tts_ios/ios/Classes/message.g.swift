// Autogenerated from Pigeon (v26.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsmessage(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsmessage(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsmessage(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashmessage(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashmessage(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashmessage(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

enum FlutterTtsErrorCode: Int {
  /// general error code for TTS engine not available.
  case ttsNotAvailable = 0
  /// The TTS engine failed to initialize in n second.
  /// 1 second is the default timeout.
  /// e.g. Some Android custom ROMS may trim TTS service,
  /// and third party TTS engine may fail to initialize due to battery optimization.
  case ttsInitTimeout = 1
  /// not supported on current os version
  case notSupportedOSVersion = 2
}

/// Audio session category identifiers for iOS.
///
/// See also:
/// * https://developer.apple.com/documentation/avfaudio/avaudiosession/category
enum IosTextToSpeechAudioCategory: Int {
  /// The default audio session category.
  ///
  /// Your audio is silenced by screen locking and by the Silent switch.
  ///
  /// By default, using this category implies that your app’s audio
  /// is nonmixable—activating your session will interrupt
  /// any other audio sessions which are also nonmixable.
  /// To allow mixing, use the [ambient] category instead.
  case ambientSolo = 0
  /// The category for an app in which sound playback is nonprimary — that is,
  /// your app also works with the sound turned off.
  ///
  /// This category is also appropriate for “play-along” apps,
  /// such as a virtual piano that a user plays while the Music app is playing.
  /// When you use this category, audio from other apps mixes with your audio.
  /// Screen locking and the Silent switch (on iPhone, the Ring/Silent switch) silence your audio.
  case ambient = 1
  /// The category for playing recorded music or other sounds
  /// that are central to the successful use of your app.
  ///
  /// When using this category, your app audio continues
  /// with the Silent switch set to silent or when the screen locks.
  ///
  /// By default, using this category implies that your app’s audio
  /// is nonmixable—activating your session will interrupt
  /// any other audio sessions which are also nonmixable.
  /// To allow mixing for this category, use the
  /// [IosTextToSpeechAudioCategoryOptions.mixWithOthers] option.
  case playback = 2
  /// The category for recording (input) and playback (output) of audio,
  /// such as for a Voice over Internet Protocol (VoIP) app.
  ///
  /// Your audio continues with the Silent switch set to silent and with the screen locked.
  /// This category is appropriate for simultaneous recording and playback,
  /// and also for apps that record and play back, but not simultaneously.
  case playAndRecord = 3
}

/// Audio session mode identifiers for iOS.
///
/// See also:
/// * https://developer.apple.com/documentation/avfaudio/avaudiosession/mode
enum IosTextToSpeechAudioMode: Int {
  /// The default audio session mode.
  ///
  /// You can use this mode with every [IosTextToSpeechAudioCategory].
  case defaultMode = 0
  /// A mode that the GameKit framework sets on behalf of an application
  /// that uses GameKit’s voice chat service.
  ///
  /// This mode is valid only with the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  ///
  /// Don’t set this mode directly. If you need similar behavior and aren’t
  /// using a `GKVoiceChat` object, use [voiceChat] or [videoChat] instead.
  case gameChat = 1
  /// A mode that indicates that your app is performing measurement of audio input or output.
  ///
  /// Use this mode for apps that need to minimize the amount of
  /// system-supplied signal processing to input and output signals.
  /// If recording on devices with more than one built-in microphone,
  /// the session uses the primary microphone.
  ///
  /// For use with the [IosTextToSpeechAudioCategory.playback] or
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  ///
  /// **Important:** This mode disables some dynamics processing on input and output signals,
  /// resulting in a lower-output playback level.
  case measurement = 2
  /// A mode that indicates that your app is playing back movie content.
  ///
  /// When you set this mode, the audio session uses signal processing to enhance
  /// movie playback for certain audio routes such as built-in speaker or headphones.
  /// You may only use this mode with the
  /// [IosTextToSpeechAudioCategory.playback] category.
  case moviePlayback = 3
  /// A mode used for continuous spoken audio to pause the audio when another app plays a short audio prompt.
  ///
  /// This mode is appropriate for apps that play continuous spoken audio,
  /// such as podcasts or audio books. Setting this mode indicates that your app
  /// should pause, rather than duck, its audio if another app plays
  /// a spoken audio prompt. After the interrupting app’s audio ends, you can
  /// resume your app’s audio playback.
  case spokenAudio = 4
  /// A mode that indicates that your app is engaging in online video conferencing.
  ///
  /// Use this mode for video chat apps that use the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  /// When you set this mode, the audio session optimizes the device’s tonal
  /// equalization for voice. It also reduces the set of allowable audio routes
  /// to only those appropriate for video chat.
  ///
  /// Using this mode has the side effect of enabling the
  /// [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
  case videoChat = 5
  /// A mode that indicates that your app is recording a movie.
  ///
  /// This mode is valid only with the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  /// On devices with more than one built-in microphone,
  /// the audio session uses the microphone closest to the video camera.
  ///
  /// Use this mode to ensure that the system provides appropriate audio-signal processing.
  case videoRecording = 6
  /// A mode that indicates that your app is performing two-way voice communication,
  /// such as using Voice over Internet Protocol (VoIP).
  ///
  /// Use this mode for Voice over IP (VoIP) apps that use the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  /// When you set this mode, the session optimizes the device’s tonal
  /// equalization for voice and reduces the set of allowable audio routes
  /// to only those appropriate for voice chat.
  ///
  /// Using this mode has the side effect of enabling the
  /// [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
  case voiceChat = 7
  /// A mode that indicates that your app plays audio using text-to-speech.
  ///
  /// Setting this mode allows for different routing behaviors when your app
  /// is connected to certain audio devices, such as CarPlay.
  /// An example of an app that uses this mode is a turn-by-turn navigation app
  /// that plays short prompts to the user.
  ///
  /// Typically, apps of the same type also configure their sessions to use the
  /// [IosTextToSpeechAudioCategoryOptions.duckOthers] and
  /// [IosTextToSpeechAudioCategoryOptions.interruptSpokenAudioAndMixWithOthers] options.
  case voicePrompt = 8
}

/// Audio session category options for iOS.
///
/// See also:
/// * https://developer.apple.com/documentation/avfaudio/avaudiosession/categoryoptions
enum IosTextToSpeechAudioCategoryOptions: Int {
  /// An option that indicates whether audio from this session mixes with audio
  /// from active sessions in other audio apps.
  ///
  /// You can set this option explicitly only if the audio session category
  /// is [IosTextToSpeechAudioCategory.playAndRecord] or
  /// [IosTextToSpeechAudioCategory.playback].
  /// If you set the audio session category to [IosTextToSpeechAudioCategory.ambient],
  /// the session automatically sets this option.
  /// Likewise, setting the [duckOthers] or [interruptSpokenAudioAndMixWithOthers]
  /// options also enables this option.
  ///
  /// If you set this option, your app mixes its audio with audio playing
  /// in background apps, such as the Music app.
  case mixWithOthers = 0
  /// An option that reduces the volume of other audio sessions while audio
  /// from this session plays.
  ///
  /// You can set this option only if the audio session category is
  /// [IosTextToSpeechAudioCategory.playAndRecord] or
  /// [IosTextToSpeechAudioCategory.playback].
  /// Setting it implicitly sets the [mixWithOthers] option.
  ///
  /// Use this option to mix your app’s audio with that of others.
  /// While your app plays its audio, the system reduces the volume of other
  /// audio sessions to make yours more prominent. If your app provides
  /// occasional spoken audio, such as in a turn-by-turn navigation app
  /// or an exercise app, you should also set the [interruptSpokenAudioAndMixWithOthers] option.
  ///
  /// Note that ducking begins when you activate your app’s audio session
  /// and ends when you deactivate the session.
  ///
  /// See also:
  /// * [FlutterTts.setSharedInstance]
  case duckOthers = 1
  /// An option that determines whether to pause spoken audio content
  /// from other sessions when your app plays its audio.
  ///
  /// You can set this option only if the audio session category is
  /// [IosTextToSpeechAudioCategory.playAndRecord] or
  /// [IosTextToSpeechAudioCategory.playback].
  /// Setting this option also sets [mixWithOthers].
  ///
  /// If you set this option, the system mixes your audio with other
  /// audio sessions, but interrupts (and stops) audio sessions that use the
  /// [IosTextToSpeechAudioMode.spokenAudio] audio session mode.
  /// It pauses the audio from other apps as long as your session is active.
  /// After your audio session deactivates, the system resumes the interrupted app’s audio.
  ///
  /// Set this option if your app’s audio is occasional and spoken,
  /// such as in a turn-by-turn navigation app or an exercise app.
  /// This avoids intelligibility problems when two spoken audio apps mix.
  /// If you set this option, also set the [duckOthers] option unless
  /// you have a specific reason not to. Ducking other audio, rather than
  /// interrupting it, is appropriate when the other audio isn’t spoken audio.
  case interruptSpokenAudioAndMixWithOthers = 2
  /// An option that determines whether Bluetooth hands-free devices appear
  /// as available input routes.
  ///
  /// You can set this option only if the audio session category is
  /// [IosTextToSpeechAudioCategory.playAndRecord] or
  /// [IosTextToSpeechAudioCategory.playback].
  ///
  /// You’re required to set this option to allow routing audio input and output
  /// to a paired Bluetooth Hands-Free Profile (HFP) device.
  /// If you clear this option, paired Bluetooth HFP devices don’t show up
  /// as available audio input routes.
  case allowBluetooth = 3
  /// An option that determines whether you can stream audio from this session
  /// to Bluetooth devices that support the Advanced Audio Distribution Profile (A2DP).
  ///
  /// A2DP is a stereo, output-only profile intended for higher bandwidth
  /// audio use cases, such as music playback.
  /// The system automatically routes to A2DP ports if you configure an
  /// app’s audio session to use the [IosTextToSpeechAudioCategory.ambient],
  /// [IosTextToSpeechAudioCategory.ambientSolo], or
  /// [IosTextToSpeechAudioCategory.playback] categories.
  ///
  /// Starting with iOS 10.0, apps using the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category may also allow
  /// routing output to paired Bluetooth A2DP devices. To enable this behavior,
  /// pass this category option when setting your audio session’s category.
  ///
  /// Note: If this option and the [allowBluetooth] option are both set,
  /// when a single device supports both the Hands-Free Profile (HFP) and A2DP,
  /// the system gives hands-free ports a higher priority for routing.
  case allowBluetoothA2DP = 4
  /// An option that determines whether you can stream audio
  /// from this session to AirPlay devices.
  ///
  /// Setting this option enables the audio session to route audio output
  /// to AirPlay devices. You can only explicitly set this option if the
  /// audio session’s category is set to [IosTextToSpeechAudioCategory.playAndRecord].
  /// For most other audio session categories, the system sets this option implicitly.
  case allowAirPlay = 5
  /// An option that determines whether audio from the session defaults to the built-in speaker instead of the receiver.
  ///
  /// You can set this option only when using the
  /// [IosTextToSpeechAudioCategory.playAndRecord] category.
  /// It’s used to modify the category’s routing behavior so that audio
  /// is always routed to the speaker rather than the receiver if
  /// no other accessories, such as headphones, are in use.
  ///
  /// When using this option, the system honors user gestures.
  /// For example, plugging in a headset causes the route to change to
  /// headset mic/headphones, and unplugging the headset causes the route
  /// to change to built-in mic/speaker (as opposed to built-in mic/receiver)
  /// when you’ve set this override.
  ///
  /// In the case of using a USB input-only accessory, audio input
  /// comes from the accessory, and the system routes audio to the headphones,
  /// if attached, or to the speaker if the headphones aren’t plugged in.
  /// The use case is to route audio to the speaker instead of the receiver
  /// in cases where the audio would normally go to the receiver.
  case defaultToSpeaker = 6
}

enum TtsPlatform: Int {
  case android = 0
  case ios = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct Voice: Hashable {
  var name: String
  var locale: String
  var gender: String? = nil
  var quality: String? = nil
  var identifier: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Voice? {
    let name = pigeonVar_list[0] as! String
    let locale = pigeonVar_list[1] as! String
    let gender: String? = nilOrValue(pigeonVar_list[2])
    let quality: String? = nilOrValue(pigeonVar_list[3])
    let identifier: String? = nilOrValue(pigeonVar_list[4])

    return Voice(
      name: name,
      locale: locale,
      gender: gender,
      quality: quality,
      identifier: identifier
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      locale,
      gender,
      quality,
      identifier,
    ]
  }
  static func == (lhs: Voice, rhs: Voice) -> Bool {
    return deepEqualsmessage(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashmessage(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TtsResult: Hashable {
  var success: Bool
  var message: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TtsResult? {
    let success = pigeonVar_list[0] as! Bool
    let message: String? = nilOrValue(pigeonVar_list[1])

    return TtsResult(
      success: success,
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      success,
      message,
    ]
  }
  static func == (lhs: TtsResult, rhs: TtsResult) -> Bool {
    return deepEqualsmessage(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashmessage(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TtsProgress: Hashable {
  var text: String
  var start: Int64
  var end: Int64
  var word: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TtsProgress? {
    let text = pigeonVar_list[0] as! String
    let start = pigeonVar_list[1] as! Int64
    let end = pigeonVar_list[2] as! Int64
    let word = pigeonVar_list[3] as! String

    return TtsProgress(
      text: text,
      start: start,
      end: end,
      word: word
    )
  }
  func toList() -> [Any?] {
    return [
      text,
      start,
      end,
      word,
    ]
  }
  static func == (lhs: TtsProgress, rhs: TtsProgress) -> Bool {
    return deepEqualsmessage(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashmessage(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TtsRateValidRange: Hashable {
  var minimum: Double
  var normal: Double
  var maximum: Double
  var platform: TtsPlatform


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TtsRateValidRange? {
    let minimum = pigeonVar_list[0] as! Double
    let normal = pigeonVar_list[1] as! Double
    let maximum = pigeonVar_list[2] as! Double
    let platform = pigeonVar_list[3] as! TtsPlatform

    return TtsRateValidRange(
      minimum: minimum,
      normal: normal,
      maximum: maximum,
      platform: platform
    )
  }
  func toList() -> [Any?] {
    return [
      minimum,
      normal,
      maximum,
      platform,
    ]
  }
  static func == (lhs: TtsRateValidRange, rhs: TtsRateValidRange) -> Bool {
    return deepEqualsmessage(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashmessage(value: toList(), hasher: &hasher)
  }
}

private class MessagePigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FlutterTtsErrorCode(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IosTextToSpeechAudioCategory(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IosTextToSpeechAudioMode(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IosTextToSpeechAudioCategoryOptions(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TtsPlatform(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      return Voice.fromList(self.readValue() as! [Any?])
    case 135:
      return TtsResult.fromList(self.readValue() as! [Any?])
    case 136:
      return TtsProgress.fromList(self.readValue() as! [Any?])
    case 137:
      return TtsRateValidRange.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MessagePigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? FlutterTtsErrorCode {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? IosTextToSpeechAudioCategory {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? IosTextToSpeechAudioMode {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? IosTextToSpeechAudioCategoryOptions {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? TtsPlatform {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? Voice {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? TtsResult {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? TtsProgress {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? TtsRateValidRange {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MessagePigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MessagePigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MessagePigeonCodecWriter(data: data)
  }
}

class MessagePigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MessagePigeonCodec(readerWriter: MessagePigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol TtsHostApi {
  func speak(text: String, forceFocus: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func pause(completion: @escaping (Result<TtsResult, Error>) -> Void)
  func stop(completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setSpeechRate(rate: Double, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setVolume(volume: Double, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setPitch(pitch: Double, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setVoice(voice: Voice, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func clearVoice(completion: @escaping (Result<TtsResult, Error>) -> Void)
  func awaitSpeakCompletion(awaitCompletion: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func getLanguages(completion: @escaping (Result<[String], Error>) -> Void)
  func getVoices(completion: @escaping (Result<[Voice], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class TtsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagePigeonCodec.shared }
  /// Sets up an instance of `TtsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: TtsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let speakChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.speak\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      speakChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let textArg = args[0] as! String
        let forceFocusArg = args[1] as! Bool
        api.speak(text: textArg, forceFocus: forceFocusArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      speakChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.pause\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { _, reply in
        api.pause { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.stop\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { _, reply in
        api.stop { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let setSpeechRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.setSpeechRate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSpeechRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let rateArg = args[0] as! Double
        api.setSpeechRate(rate: rateArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSpeechRateChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.setVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let volumeArg = args[0] as! Double
        api.setVolume(volume: volumeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let setPitchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.setPitch\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPitchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pitchArg = args[0] as! Double
        api.setPitch(pitch: pitchArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPitchChannel.setMessageHandler(nil)
    }
    let setVoiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.setVoice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVoiceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let voiceArg = args[0] as! Voice
        api.setVoice(voice: voiceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVoiceChannel.setMessageHandler(nil)
    }
    let clearVoiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.clearVoice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearVoiceChannel.setMessageHandler { _, reply in
        api.clearVoice { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearVoiceChannel.setMessageHandler(nil)
    }
    let awaitSpeakCompletionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.awaitSpeakCompletion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      awaitSpeakCompletionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let awaitCompletionArg = args[0] as! Bool
        api.awaitSpeakCompletion(awaitCompletion: awaitCompletionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      awaitSpeakCompletionChannel.setMessageHandler(nil)
    }
    let getLanguagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.getLanguages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLanguagesChannel.setMessageHandler { _, reply in
        api.getLanguages { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getLanguagesChannel.setMessageHandler(nil)
    }
    let getVoicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.TtsHostApi.getVoices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVoicesChannel.setMessageHandler { _, reply in
        api.getVoices { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVoicesChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IosTtsHostApi {
  func awaitSynthCompletion(awaitCompletion: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func synthesizeToFile(text: String, fileName: String, isFullPath: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setSharedInstance(sharedSession: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func autoStopSharedSession(autoStop: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setIosAudioCategory(category: IosTextToSpeechAudioCategory, options: [IosTextToSpeechAudioCategoryOptions], mode: IosTextToSpeechAudioMode, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func getSpeechRateValidRange(completion: @escaping (Result<TtsRateValidRange, Error>) -> Void)
  func isLanguageAvailable(language: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func setLanguange(language: String, completion: @escaping (Result<TtsResult, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IosTtsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagePigeonCodec.shared }
  /// Sets up an instance of `IosTtsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IosTtsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let awaitSynthCompletionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.awaitSynthCompletion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      awaitSynthCompletionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let awaitCompletionArg = args[0] as! Bool
        api.awaitSynthCompletion(awaitCompletion: awaitCompletionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      awaitSynthCompletionChannel.setMessageHandler(nil)
    }
    let synthesizeToFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.synthesizeToFile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      synthesizeToFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let textArg = args[0] as! String
        let fileNameArg = args[1] as! String
        let isFullPathArg = args[2] as! Bool
        api.synthesizeToFile(text: textArg, fileName: fileNameArg, isFullPath: isFullPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      synthesizeToFileChannel.setMessageHandler(nil)
    }
    let setSharedInstanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setSharedInstance\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSharedInstanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sharedSessionArg = args[0] as! Bool
        api.setSharedInstance(sharedSession: sharedSessionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSharedInstanceChannel.setMessageHandler(nil)
    }
    let autoStopSharedSessionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.autoStopSharedSession\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      autoStopSharedSessionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let autoStopArg = args[0] as! Bool
        api.autoStopSharedSession(autoStop: autoStopArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      autoStopSharedSessionChannel.setMessageHandler(nil)
    }
    let setIosAudioCategoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setIosAudioCategory\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIosAudioCategoryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let categoryArg = args[0] as! IosTextToSpeechAudioCategory
        let optionsArg = args[1] as! [IosTextToSpeechAudioCategoryOptions]
        let modeArg = args[2] as! IosTextToSpeechAudioMode
        api.setIosAudioCategory(category: categoryArg, options: optionsArg, mode: modeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIosAudioCategoryChannel.setMessageHandler(nil)
    }
    let getSpeechRateValidRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.getSpeechRateValidRange\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpeechRateValidRangeChannel.setMessageHandler { _, reply in
        api.getSpeechRateValidRange { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSpeechRateValidRangeChannel.setMessageHandler(nil)
    }
    let isLanguageAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.isLanguageAvailable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLanguageAvailableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.isLanguageAvailable(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isLanguageAvailableChannel.setMessageHandler(nil)
    }
    let setLanguangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setLanguange\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLanguangeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.setLanguange(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLanguangeChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AndroidTtsHostApi {
  func awaitSynthCompletion(awaitCompletion: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func getMaxSpeechInputLength(completion: @escaping (Result<Int64?, Error>) -> Void)
  func setEngine(engine: String, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func getEngines(completion: @escaping (Result<[String], Error>) -> Void)
  func getDefaultEngine(completion: @escaping (Result<String?, Error>) -> Void)
  func getDefaultVoice(completion: @escaping (Result<Voice?, Error>) -> Void)
  /// [Future] which invokes the platform specific method for synthesizeToFile
  func synthesizeToFile(text: String, fileName: String, isFullPath: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func isLanguageInstalled(language: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func isLanguageAvailable(language: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func areLanguagesInstalled(languages: [String], completion: @escaping (Result<[String: Bool], Error>) -> Void)
  func getSpeechRateValidRange(completion: @escaping (Result<TtsRateValidRange, Error>) -> Void)
  func setSilence(timems: Int64, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setQueueMode(queueMode: Int64, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func setAudioAttributesForNavigation(completion: @escaping (Result<TtsResult, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AndroidTtsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagePigeonCodec.shared }
  /// Sets up an instance of `AndroidTtsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AndroidTtsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let awaitSynthCompletionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.awaitSynthCompletion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      awaitSynthCompletionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let awaitCompletionArg = args[0] as! Bool
        api.awaitSynthCompletion(awaitCompletion: awaitCompletionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      awaitSynthCompletionChannel.setMessageHandler(nil)
    }
    let getMaxSpeechInputLengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getMaxSpeechInputLength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMaxSpeechInputLengthChannel.setMessageHandler { _, reply in
        api.getMaxSpeechInputLength { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getMaxSpeechInputLengthChannel.setMessageHandler(nil)
    }
    let setEngineChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setEngine\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setEngineChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let engineArg = args[0] as! String
        api.setEngine(engine: engineArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setEngineChannel.setMessageHandler(nil)
    }
    let getEnginesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getEngines\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEnginesChannel.setMessageHandler { _, reply in
        api.getEngines { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getEnginesChannel.setMessageHandler(nil)
    }
    let getDefaultEngineChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getDefaultEngine\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDefaultEngineChannel.setMessageHandler { _, reply in
        api.getDefaultEngine { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDefaultEngineChannel.setMessageHandler(nil)
    }
    let getDefaultVoiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getDefaultVoice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDefaultVoiceChannel.setMessageHandler { _, reply in
        api.getDefaultVoice { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDefaultVoiceChannel.setMessageHandler(nil)
    }
    /// [Future] which invokes the platform specific method for synthesizeToFile
    let synthesizeToFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.synthesizeToFile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      synthesizeToFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let textArg = args[0] as! String
        let fileNameArg = args[1] as! String
        let isFullPathArg = args[2] as! Bool
        api.synthesizeToFile(text: textArg, fileName: fileNameArg, isFullPath: isFullPathArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      synthesizeToFileChannel.setMessageHandler(nil)
    }
    let isLanguageInstalledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.isLanguageInstalled\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLanguageInstalledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.isLanguageInstalled(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isLanguageInstalledChannel.setMessageHandler(nil)
    }
    let isLanguageAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.isLanguageAvailable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLanguageAvailableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.isLanguageAvailable(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isLanguageAvailableChannel.setMessageHandler(nil)
    }
    let areLanguagesInstalledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.areLanguagesInstalled\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      areLanguagesInstalledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languagesArg = args[0] as! [String]
        api.areLanguagesInstalled(languages: languagesArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      areLanguagesInstalledChannel.setMessageHandler(nil)
    }
    let getSpeechRateValidRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getSpeechRateValidRange\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpeechRateValidRangeChannel.setMessageHandler { _, reply in
        api.getSpeechRateValidRange { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSpeechRateValidRangeChannel.setMessageHandler(nil)
    }
    let setSilenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setSilence\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSilenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let timemsArg = args[0] as! Int64
        api.setSilence(timems: timemsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSilenceChannel.setMessageHandler(nil)
    }
    let setQueueModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setQueueMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setQueueModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let queueModeArg = args[0] as! Int64
        api.setQueueMode(queueMode: queueModeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setQueueModeChannel.setMessageHandler(nil)
    }
    let setAudioAttributesForNavigationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setAudioAttributesForNavigation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAudioAttributesForNavigationChannel.setMessageHandler { _, reply in
        api.setAudioAttributesForNavigation { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAudioAttributesForNavigationChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol MacosTtsHostApi {
  func awaitSynthCompletion(awaitCompletion: Bool, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func getSpeechRateValidRange(completion: @escaping (Result<TtsRateValidRange, Error>) -> Void)
  func setLanguange(language: String, completion: @escaping (Result<TtsResult, Error>) -> Void)
  func isLanguageAvailable(language: String, completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class MacosTtsHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagePigeonCodec.shared }
  /// Sets up an instance of `MacosTtsHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: MacosTtsHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let awaitSynthCompletionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.awaitSynthCompletion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      awaitSynthCompletionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let awaitCompletionArg = args[0] as! Bool
        api.awaitSynthCompletion(awaitCompletion: awaitCompletionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      awaitSynthCompletionChannel.setMessageHandler(nil)
    }
    let getSpeechRateValidRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.getSpeechRateValidRange\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpeechRateValidRangeChannel.setMessageHandler { _, reply in
        api.getSpeechRateValidRange { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSpeechRateValidRangeChannel.setMessageHandler(nil)
    }
    let setLanguangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.setLanguange\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLanguangeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.setLanguange(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLanguangeChannel.setMessageHandler(nil)
    }
    let isLanguageAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.isLanguageAvailable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLanguageAvailableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg = args[0] as! String
        api.isLanguageAvailable(language: languageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isLanguageAvailableChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol TtsFlutterApiProtocol {
  func onSpeakStartCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakCompleteCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakPauseCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakResumeCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakCancelCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakProgressCb(progress progressArg: TtsProgress, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSpeakErrorCb(error errorArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSynthStartCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSynthCompleteCb(completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onSynthErrorCb(error errorArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class TtsFlutterApi: TtsFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: MessagePigeonCodec {
    return MessagePigeonCodec.shared
  }
  func onSpeakStartCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakStartCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakCompleteCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakCompleteCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakPauseCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakPauseCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakResumeCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakResumeCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakCancelCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakCancelCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakProgressCb(progress progressArg: TtsProgress, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakProgressCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSpeakErrorCb(error errorArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakErrorCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSynthStartCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthStartCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSynthCompleteCb(completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthCompleteCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onSynthErrorCb(error errorArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthErrorCb\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
