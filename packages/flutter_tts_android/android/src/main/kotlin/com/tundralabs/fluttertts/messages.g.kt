// Autogenerated from Pigeon (v26.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.tundralabs.fluttertts

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object MessagesPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).contains(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class FlutterTtsErrorCode(val raw: Int) {
  /** general error code for TTS engine not available. */
  TTS_NOT_AVAILABLE(0),
  /**
   * The TTS engine failed to initialize in n second.
   * 1 second is the default timeout.
   * e.g. Some Android custom ROMS may trim TTS service,
   * and third party TTS engine may fail to initialize due to battery optimization.
   */
  TTS_INIT_TIMEOUT(1),
  /** not supported on current os version */
  NOT_SUPPORTED_OSVERSION(2);

  companion object {
    fun ofRaw(raw: Int): FlutterTtsErrorCode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Audio session category identifiers for iOS.
 *
 * See also:
 * * https://developer.apple.com/documentation/avfaudio/avaudiosession/category
 */
enum class IosTextToSpeechAudioCategory(val raw: Int) {
  /**
   * The default audio session category.
   *
   * Your audio is silenced by screen locking and by the Silent switch.
   *
   * By default, using this category implies that your app’s audio
   * is nonmixable—activating your session will interrupt
   * any other audio sessions which are also nonmixable.
   * To allow mixing, use the [ambient] category instead.
   */
  AMBIENT_SOLO(0),
  /**
   * The category for an app in which sound playback is nonprimary — that is,
   * your app also works with the sound turned off.
   *
   * This category is also appropriate for “play-along” apps,
   * such as a virtual piano that a user plays while the Music app is playing.
   * When you use this category, audio from other apps mixes with your audio.
   * Screen locking and the Silent switch (on iPhone, the Ring/Silent switch) silence your audio.
   */
  AMBIENT(1),
  /**
   * The category for playing recorded music or other sounds
   * that are central to the successful use of your app.
   *
   * When using this category, your app audio continues
   * with the Silent switch set to silent or when the screen locks.
   *
   * By default, using this category implies that your app’s audio
   * is nonmixable—activating your session will interrupt
   * any other audio sessions which are also nonmixable.
   * To allow mixing for this category, use the
   * [IosTextToSpeechAudioCategoryOptions.mixWithOthers] option.
   */
  PLAYBACK(2),
  /**
   * The category for recording (input) and playback (output) of audio,
   * such as for a Voice over Internet Protocol (VoIP) app.
   *
   * Your audio continues with the Silent switch set to silent and with the screen locked.
   * This category is appropriate for simultaneous recording and playback,
   * and also for apps that record and play back, but not simultaneously.
   */
  PLAY_AND_RECORD(3);

  companion object {
    fun ofRaw(raw: Int): IosTextToSpeechAudioCategory? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Audio session mode identifiers for iOS.
 *
 * See also:
 * * https://developer.apple.com/documentation/avfaudio/avaudiosession/mode
 */
enum class IosTextToSpeechAudioMode(val raw: Int) {
  /**
   * The default audio session mode.
   *
   * You can use this mode with every [IosTextToSpeechAudioCategory].
   */
  DEFAULT_MODE(0),
  /**
   * A mode that the GameKit framework sets on behalf of an application
   * that uses GameKit’s voice chat service.
   *
   * This mode is valid only with the
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   *
   * Don’t set this mode directly. If you need similar behavior and aren’t
   * using a `GKVoiceChat` object, use [voiceChat] or [videoChat] instead.
   */
  GAME_CHAT(1),
  /**
   * A mode that indicates that your app is performing measurement of audio input or output.
   *
   * Use this mode for apps that need to minimize the amount of
   * system-supplied signal processing to input and output signals.
   * If recording on devices with more than one built-in microphone,
   * the session uses the primary microphone.
   *
   * For use with the [IosTextToSpeechAudioCategory.playback] or
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   *
   * **Important:** This mode disables some dynamics processing on input and output signals,
   * resulting in a lower-output playback level.
   */
  MEASUREMENT(2),
  /**
   * A mode that indicates that your app is playing back movie content.
   *
   * When you set this mode, the audio session uses signal processing to enhance
   * movie playback for certain audio routes such as built-in speaker or headphones.
   * You may only use this mode with the
   * [IosTextToSpeechAudioCategory.playback] category.
   */
  MOVIE_PLAYBACK(3),
  /**
   * A mode used for continuous spoken audio to pause the audio when another app plays a short audio prompt.
   *
   * This mode is appropriate for apps that play continuous spoken audio,
   * such as podcasts or audio books. Setting this mode indicates that your app
   * should pause, rather than duck, its audio if another app plays
   * a spoken audio prompt. After the interrupting app’s audio ends, you can
   * resume your app’s audio playback.
   */
  SPOKEN_AUDIO(4),
  /**
   * A mode that indicates that your app is engaging in online video conferencing.
   *
   * Use this mode for video chat apps that use the
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   * When you set this mode, the audio session optimizes the device’s tonal
   * equalization for voice. It also reduces the set of allowable audio routes
   * to only those appropriate for video chat.
   *
   * Using this mode has the side effect of enabling the
   * [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
   */
  VIDEO_CHAT(5),
  /**
   * A mode that indicates that your app is recording a movie.
   *
   * This mode is valid only with the
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   * On devices with more than one built-in microphone,
   * the audio session uses the microphone closest to the video camera.
   *
   * Use this mode to ensure that the system provides appropriate audio-signal processing.
   */
  VIDEO_RECORDING(6),
  /**
   * A mode that indicates that your app is performing two-way voice communication,
   * such as using Voice over Internet Protocol (VoIP).
   *
   * Use this mode for Voice over IP (VoIP) apps that use the
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   * When you set this mode, the session optimizes the device’s tonal
   * equalization for voice and reduces the set of allowable audio routes
   * to only those appropriate for voice chat.
   *
   * Using this mode has the side effect of enabling the
   * [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
   */
  VOICE_CHAT(7),
  /**
   * A mode that indicates that your app plays audio using text-to-speech.
   *
   * Setting this mode allows for different routing behaviors when your app
   * is connected to certain audio devices, such as CarPlay.
   * An example of an app that uses this mode is a turn-by-turn navigation app
   * that plays short prompts to the user.
   *
   * Typically, apps of the same type also configure their sessions to use the
   * [IosTextToSpeechAudioCategoryOptions.duckOthers] and
   * [IosTextToSpeechAudioCategoryOptions.interruptSpokenAudioAndMixWithOthers] options.
   */
  VOICE_PROMPT(8);

  companion object {
    fun ofRaw(raw: Int): IosTextToSpeechAudioMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Audio session category options for iOS.
 *
 * See also:
 * * https://developer.apple.com/documentation/avfaudio/avaudiosession/categoryoptions
 */
enum class IosTextToSpeechAudioCategoryOptions(val raw: Int) {
  /**
   * An option that indicates whether audio from this session mixes with audio
   * from active sessions in other audio apps.
   *
   * You can set this option explicitly only if the audio session category
   * is [IosTextToSpeechAudioCategory.playAndRecord] or
   * [IosTextToSpeechAudioCategory.playback].
   * If you set the audio session category to [IosTextToSpeechAudioCategory.ambient],
   * the session automatically sets this option.
   * Likewise, setting the [duckOthers] or [interruptSpokenAudioAndMixWithOthers]
   * options also enables this option.
   *
   * If you set this option, your app mixes its audio with audio playing
   * in background apps, such as the Music app.
   */
  MIX_WITH_OTHERS(0),
  /**
   * An option that reduces the volume of other audio sessions while audio
   * from this session plays.
   *
   * You can set this option only if the audio session category is
   * [IosTextToSpeechAudioCategory.playAndRecord] or
   * [IosTextToSpeechAudioCategory.playback].
   * Setting it implicitly sets the [mixWithOthers] option.
   *
   * Use this option to mix your app’s audio with that of others.
   * While your app plays its audio, the system reduces the volume of other
   * audio sessions to make yours more prominent. If your app provides
   * occasional spoken audio, such as in a turn-by-turn navigation app
   * or an exercise app, you should also set the [interruptSpokenAudioAndMixWithOthers] option.
   *
   * Note that ducking begins when you activate your app’s audio session
   * and ends when you deactivate the session.
   *
   * See also:
   * * [FlutterTts.setSharedInstance]
   */
  DUCK_OTHERS(1),
  /**
   * An option that determines whether to pause spoken audio content
   * from other sessions when your app plays its audio.
   *
   * You can set this option only if the audio session category is
   * [IosTextToSpeechAudioCategory.playAndRecord] or
   * [IosTextToSpeechAudioCategory.playback].
   * Setting this option also sets [mixWithOthers].
   *
   * If you set this option, the system mixes your audio with other
   * audio sessions, but interrupts (and stops) audio sessions that use the
   * [IosTextToSpeechAudioMode.spokenAudio] audio session mode.
   * It pauses the audio from other apps as long as your session is active.
   * After your audio session deactivates, the system resumes the interrupted app’s audio.
   *
   * Set this option if your app’s audio is occasional and spoken,
   * such as in a turn-by-turn navigation app or an exercise app.
   * This avoids intelligibility problems when two spoken audio apps mix.
   * If you set this option, also set the [duckOthers] option unless
   * you have a specific reason not to. Ducking other audio, rather than
   * interrupting it, is appropriate when the other audio isn’t spoken audio.
   */
  INTERRUPT_SPOKEN_AUDIO_AND_MIX_WITH_OTHERS(2),
  /**
   * An option that determines whether Bluetooth hands-free devices appear
   * as available input routes.
   *
   * You can set this option only if the audio session category is
   * [IosTextToSpeechAudioCategory.playAndRecord] or
   * [IosTextToSpeechAudioCategory.playback].
   *
   * You’re required to set this option to allow routing audio input and output
   * to a paired Bluetooth Hands-Free Profile (HFP) device.
   * If you clear this option, paired Bluetooth HFP devices don’t show up
   * as available audio input routes.
   */
  ALLOW_BLUETOOTH(3),
  /**
   * An option that determines whether you can stream audio from this session
   * to Bluetooth devices that support the Advanced Audio Distribution Profile (A2DP).
   *
   * A2DP is a stereo, output-only profile intended for higher bandwidth
   * audio use cases, such as music playback.
   * The system automatically routes to A2DP ports if you configure an
   * app’s audio session to use the [IosTextToSpeechAudioCategory.ambient],
   * [IosTextToSpeechAudioCategory.ambientSolo], or
   * [IosTextToSpeechAudioCategory.playback] categories.
   *
   * Starting with iOS 10.0, apps using the
   * [IosTextToSpeechAudioCategory.playAndRecord] category may also allow
   * routing output to paired Bluetooth A2DP devices. To enable this behavior,
   * pass this category option when setting your audio session’s category.
   *
   * Note: If this option and the [allowBluetooth] option are both set,
   * when a single device supports both the Hands-Free Profile (HFP) and A2DP,
   * the system gives hands-free ports a higher priority for routing.
   */
  ALLOW_BLUETOOTH_A2DP(4),
  /**
   * An option that determines whether you can stream audio
   * from this session to AirPlay devices.
   *
   * Setting this option enables the audio session to route audio output
   * to AirPlay devices. You can only explicitly set this option if the
   * audio session’s category is set to [IosTextToSpeechAudioCategory.playAndRecord].
   * For most other audio session categories, the system sets this option implicitly.
   */
  ALLOW_AIR_PLAY(5),
  /**
   * An option that determines whether audio from the session defaults to the built-in speaker instead of the receiver.
   *
   * You can set this option only when using the
   * [IosTextToSpeechAudioCategory.playAndRecord] category.
   * It’s used to modify the category’s routing behavior so that audio
   * is always routed to the speaker rather than the receiver if
   * no other accessories, such as headphones, are in use.
   *
   * When using this option, the system honors user gestures.
   * For example, plugging in a headset causes the route to change to
   * headset mic/headphones, and unplugging the headset causes the route
   * to change to built-in mic/speaker (as opposed to built-in mic/receiver)
   * when you’ve set this override.
   *
   * In the case of using a USB input-only accessory, audio input
   * comes from the accessory, and the system routes audio to the headphones,
   * if attached, or to the speaker if the headphones aren’t plugged in.
   * The use case is to route audio to the speaker instead of the receiver
   * in cases where the audio would normally go to the receiver.
   */
  DEFAULT_TO_SPEAKER(6);

  companion object {
    fun ofRaw(raw: Int): IosTextToSpeechAudioCategoryOptions? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TtsPlatform(val raw: Int) {
  ANDROID(0),
  IOS(1);

  companion object {
    fun ofRaw(raw: Int): TtsPlatform? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Voice (
  val name: String,
  val locale: String,
  val gender: String? = null,
  val quality: String? = null,
  val identifier: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Voice {
      val name = pigeonVar_list[0] as String
      val locale = pigeonVar_list[1] as String
      val gender = pigeonVar_list[2] as String?
      val quality = pigeonVar_list[3] as String?
      val identifier = pigeonVar_list[4] as String?
      return Voice(name, locale, gender, quality, identifier)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      name,
      locale,
      gender,
      quality,
      identifier,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is Voice) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TtsResult (
  val success: Boolean,
  val message: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TtsResult {
      val success = pigeonVar_list[0] as Boolean
      val message = pigeonVar_list[1] as String?
      return TtsResult(success, message)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      success,
      message,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TtsResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TtsProgress (
  val text: String,
  val start: Long,
  val end: Long,
  val word: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TtsProgress {
      val text = pigeonVar_list[0] as String
      val start = pigeonVar_list[1] as Long
      val end = pigeonVar_list[2] as Long
      val word = pigeonVar_list[3] as String
      return TtsProgress(text, start, end, word)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      text,
      start,
      end,
      word,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TtsProgress) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TtsRateValidRange (
  val minimum: Double,
  val normal: Double,
  val maximum: Double,
  val platform: TtsPlatform
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TtsRateValidRange {
      val minimum = pigeonVar_list[0] as Double
      val normal = pigeonVar_list[1] as Double
      val maximum = pigeonVar_list[2] as Double
      val platform = pigeonVar_list[3] as TtsPlatform
      return TtsRateValidRange(minimum, normal, maximum, platform)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      minimum,
      normal,
      maximum,
      platform,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TtsRateValidRange) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class messagesPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          FlutterTtsErrorCode.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IosTextToSpeechAudioCategory.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IosTextToSpeechAudioMode.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IosTextToSpeechAudioCategoryOptions.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TtsPlatform.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Voice.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TtsResult.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TtsProgress.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TtsRateValidRange.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is FlutterTtsErrorCode -> {
        stream.write(129)
        writeValue(stream, value.raw.toLong())
      }
      is IosTextToSpeechAudioCategory -> {
        stream.write(130)
        writeValue(stream, value.raw.toLong())
      }
      is IosTextToSpeechAudioMode -> {
        stream.write(131)
        writeValue(stream, value.raw.toLong())
      }
      is IosTextToSpeechAudioCategoryOptions -> {
        stream.write(132)
        writeValue(stream, value.raw.toLong())
      }
      is TtsPlatform -> {
        stream.write(133)
        writeValue(stream, value.raw.toLong())
      }
      is Voice -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is TtsResult -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is TtsProgress -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is TtsRateValidRange -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface TtsHostApi {
  fun speak(text: String, forceFocus: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun pause(callback: (Result<TtsResult>) -> Unit)
  fun stop(callback: (Result<TtsResult>) -> Unit)
  fun setSpeechRate(rate: Double, callback: (Result<TtsResult>) -> Unit)
  fun setVolume(volume: Double, callback: (Result<TtsResult>) -> Unit)
  fun setPitch(pitch: Double, callback: (Result<TtsResult>) -> Unit)
  fun setVoice(voice: Voice, callback: (Result<TtsResult>) -> Unit)
  fun clearVoice(callback: (Result<TtsResult>) -> Unit)
  fun awaitSpeakCompletion(awaitCompletion: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun getLanguages(callback: (Result<List<String>>) -> Unit)
  fun getVoices(callback: (Result<List<Voice>>) -> Unit)

  companion object {
    /** The codec used by TtsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      messagesPigeonCodec()
    }
    /** Sets up an instance of `TtsHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: TtsHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.speak$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textArg = args[0] as String
            val forceFocusArg = args[1] as Boolean
            api.speak(textArg, forceFocusArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.pause$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.pause{ result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.stop$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.stop{ result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.setSpeechRate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val rateArg = args[0] as Double
            api.setSpeechRate(rateArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.setVolume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val volumeArg = args[0] as Double
            api.setVolume(volumeArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.setPitch$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pitchArg = args[0] as Double
            api.setPitch(pitchArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.setVoice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val voiceArg = args[0] as Voice
            api.setVoice(voiceArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.clearVoice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.clearVoice{ result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.awaitSpeakCompletion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val awaitCompletionArg = args[0] as Boolean
            api.awaitSpeakCompletion(awaitCompletionArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.getLanguages$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getLanguages{ result: Result<List<String>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.TtsHostApi.getVoices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getVoices{ result: Result<List<Voice>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface IosTtsHostApi {
  fun awaitSynthCompletion(awaitCompletion: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun synthesizeToFile(text: String, fileName: String, isFullPath: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun setSharedInstance(sharedSession: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun autoStopSharedSession(autoStop: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun setIosAudioCategory(category: IosTextToSpeechAudioCategory, options: List<IosTextToSpeechAudioCategoryOptions>, mode: IosTextToSpeechAudioMode, callback: (Result<TtsResult>) -> Unit)
  fun getSpeechRateValidRange(callback: (Result<TtsRateValidRange>) -> Unit)
  fun isLanguageAvailable(language: String, callback: (Result<Boolean>) -> Unit)
  fun setLanguange(language: String, callback: (Result<TtsResult>) -> Unit)

  companion object {
    /** The codec used by IosTtsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      messagesPigeonCodec()
    }
    /** Sets up an instance of `IosTtsHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: IosTtsHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.awaitSynthCompletion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val awaitCompletionArg = args[0] as Boolean
            api.awaitSynthCompletion(awaitCompletionArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.synthesizeToFile$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textArg = args[0] as String
            val fileNameArg = args[1] as String
            val isFullPathArg = args[2] as Boolean
            api.synthesizeToFile(textArg, fileNameArg, isFullPathArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setSharedInstance$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sharedSessionArg = args[0] as Boolean
            api.setSharedInstance(sharedSessionArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.autoStopSharedSession$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val autoStopArg = args[0] as Boolean
            api.autoStopSharedSession(autoStopArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setIosAudioCategory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val categoryArg = args[0] as IosTextToSpeechAudioCategory
            val optionsArg = args[1] as List<IosTextToSpeechAudioCategoryOptions>
            val modeArg = args[2] as IosTextToSpeechAudioMode
            api.setIosAudioCategory(categoryArg, optionsArg, modeArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.getSpeechRateValidRange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getSpeechRateValidRange{ result: Result<TtsRateValidRange> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.isLanguageAvailable$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.isLanguageAvailable(languageArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.IosTtsHostApi.setLanguange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.setLanguange(languageArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface AndroidTtsHostApi {
  fun awaitSynthCompletion(awaitCompletion: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun getMaxSpeechInputLength(callback: (Result<Long?>) -> Unit)
  fun setEngine(engine: String, callback: (Result<TtsResult>) -> Unit)
  fun getEngines(callback: (Result<List<String>>) -> Unit)
  fun getDefaultEngine(callback: (Result<String?>) -> Unit)
  fun getDefaultVoice(callback: (Result<Voice?>) -> Unit)
  /** [Future] which invokes the platform specific method for synthesizeToFile */
  fun synthesizeToFile(text: String, fileName: String, isFullPath: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun isLanguageInstalled(language: String, callback: (Result<Boolean>) -> Unit)
  fun isLanguageAvailable(language: String, callback: (Result<Boolean>) -> Unit)
  fun areLanguagesInstalled(languages: List<String>, callback: (Result<Map<String, Boolean>>) -> Unit)
  fun getSpeechRateValidRange(callback: (Result<TtsRateValidRange>) -> Unit)
  fun setSilence(timems: Long, callback: (Result<TtsResult>) -> Unit)
  fun setQueueMode(queueMode: Long, callback: (Result<TtsResult>) -> Unit)
  fun setAudioAttributesForNavigation(callback: (Result<TtsResult>) -> Unit)

  companion object {
    /** The codec used by AndroidTtsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      messagesPigeonCodec()
    }
    /** Sets up an instance of `AndroidTtsHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: AndroidTtsHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.awaitSynthCompletion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val awaitCompletionArg = args[0] as Boolean
            api.awaitSynthCompletion(awaitCompletionArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getMaxSpeechInputLength$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getMaxSpeechInputLength{ result: Result<Long?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setEngine$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val engineArg = args[0] as String
            api.setEngine(engineArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getEngines$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getEngines{ result: Result<List<String>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getDefaultEngine$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getDefaultEngine{ result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getDefaultVoice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getDefaultVoice{ result: Result<Voice?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.synthesizeToFile$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textArg = args[0] as String
            val fileNameArg = args[1] as String
            val isFullPathArg = args[2] as Boolean
            api.synthesizeToFile(textArg, fileNameArg, isFullPathArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.isLanguageInstalled$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.isLanguageInstalled(languageArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.isLanguageAvailable$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.isLanguageAvailable(languageArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.areLanguagesInstalled$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languagesArg = args[0] as List<String>
            api.areLanguagesInstalled(languagesArg) { result: Result<Map<String, Boolean>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.getSpeechRateValidRange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getSpeechRateValidRange{ result: Result<TtsRateValidRange> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setSilence$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val timemsArg = args[0] as Long
            api.setSilence(timemsArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setQueueMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queueModeArg = args[0] as Long
            api.setQueueMode(queueModeArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.AndroidTtsHostApi.setAudioAttributesForNavigation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.setAudioAttributesForNavigation{ result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface MacosTtsHostApi {
  fun awaitSynthCompletion(awaitCompletion: Boolean, callback: (Result<TtsResult>) -> Unit)
  fun getSpeechRateValidRange(callback: (Result<TtsRateValidRange>) -> Unit)
  fun setLanguange(language: String, callback: (Result<TtsResult>) -> Unit)
  fun isLanguageAvailable(language: String, callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by MacosTtsHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      messagesPigeonCodec()
    }
    /** Sets up an instance of `MacosTtsHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: MacosTtsHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.awaitSynthCompletion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val awaitCompletionArg = args[0] as Boolean
            api.awaitSynthCompletion(awaitCompletionArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.getSpeechRateValidRange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getSpeechRateValidRange{ result: Result<TtsRateValidRange> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.setLanguange$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.setLanguange(languageArg) { result: Result<TtsResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_tts.MacosTtsHostApi.isLanguageAvailable$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String
            api.isLanguageAvailable(languageArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class TtsFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by TtsFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      messagesPigeonCodec()
    }
  }
  fun onSpeakStartCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakStartCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakCompleteCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakCompleteCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakPauseCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakPauseCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakResumeCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakResumeCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakCancelCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakCancelCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakProgressCb(progressArg: TtsProgress, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakProgressCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(progressArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSpeakErrorCb(errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSpeakErrorCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSynthStartCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthStartCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSynthCompleteCb(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthCompleteCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSynthErrorCb(errorArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_tts.TtsFlutterApi.onSynthErrorCb$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
