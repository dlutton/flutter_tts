// Autogenerated from Pigeon (v26.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#ifndef PIGEON_MESSAGES_G_H_
#define PIGEON_MESSAGES_G_H_
#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace flutter_tts {


// Generated class from Pigeon.

class FlutterError {
 public:
  explicit FlutterError(const std::string& code)
    : code_(code) {}
  explicit FlutterError(const std::string& code, const std::string& message)
    : code_(code), message_(message) {}
  explicit FlutterError(const std::string& code, const std::string& message, const flutter::EncodableValue& details)
    : code_(code), message_(message), details_(details) {}

  const std::string& code() const { return code_; }
  const std::string& message() const { return message_; }
  const flutter::EncodableValue& details() const { return details_; }

 private:
  std::string code_;
  std::string message_;
  flutter::EncodableValue details_;
};

template<class T> class ErrorOr {
 public:
  ErrorOr(const T& rhs) : v_(rhs) {}
  ErrorOr(const T&& rhs) : v_(std::move(rhs)) {}
  ErrorOr(const FlutterError& rhs) : v_(rhs) {}
  ErrorOr(const FlutterError&& rhs) : v_(std::move(rhs)) {}

  bool has_error() const { return std::holds_alternative<FlutterError>(v_); }
  const T& value() const { return std::get<T>(v_); };
  const FlutterError& error() const { return std::get<FlutterError>(v_); };

 private:
  friend class TtsHostApi;
  friend class IosTtsHostApi;
  friend class AndroidTtsHostApi;
  friend class MacosTtsHostApi;
  friend class TtsFlutterApi;
  ErrorOr() = default;
  T TakeValue() && { return std::get<T>(std::move(v_)); }

  std::variant<T, FlutterError> v_;
};


enum class FlutterTtsErrorCode {
  // general error code for TTS engine not available.
  kTtsNotAvailable = 0,
  // The TTS engine failed to initialize in n second.
  // 1 second is the default timeout.
  // e.g. Some Android custom ROMS may trim TTS service,
  // and third party TTS engine may fail to initialize due to battery optimization.
  kTtsInitTimeout = 1,
  // not supported on current os version
  kNotSupportedOSVersion = 2
};

// Audio session category identifiers for iOS.
//
// See also:
// * https://developer.apple.com/documentation/avfaudio/avaudiosession/category
enum class IosTextToSpeechAudioCategory {
  // The default audio session category.
  //
  // Your audio is silenced by screen locking and by the Silent switch.
  //
  // By default, using this category implies that your app’s audio
  // is nonmixable—activating your session will interrupt
  // any other audio sessions which are also nonmixable.
  // To allow mixing, use the [ambient] category instead.
  kAmbientSolo = 0,
  // The category for an app in which sound playback is nonprimary — that is,
  // your app also works with the sound turned off.
  //
  // This category is also appropriate for “play-along” apps,
  // such as a virtual piano that a user plays while the Music app is playing.
  // When you use this category, audio from other apps mixes with your audio.
  // Screen locking and the Silent switch (on iPhone, the Ring/Silent switch) silence your audio.
  kAmbient = 1,
  // The category for playing recorded music or other sounds
  // that are central to the successful use of your app.
  //
  // When using this category, your app audio continues
  // with the Silent switch set to silent or when the screen locks.
  //
  // By default, using this category implies that your app’s audio
  // is nonmixable—activating your session will interrupt
  // any other audio sessions which are also nonmixable.
  // To allow mixing for this category, use the
  // [IosTextToSpeechAudioCategoryOptions.mixWithOthers] option.
  kPlayback = 2,
  // The category for recording (input) and playback (output) of audio,
  // such as for a Voice over Internet Protocol (VoIP) app.
  //
  // Your audio continues with the Silent switch set to silent and with the screen locked.
  // This category is appropriate for simultaneous recording and playback,
  // and also for apps that record and play back, but not simultaneously.
  kPlayAndRecord = 3
};

// Audio session mode identifiers for iOS.
//
// See also:
// * https://developer.apple.com/documentation/avfaudio/avaudiosession/mode
enum class IosTextToSpeechAudioMode {
  // The default audio session mode.
  //
  // You can use this mode with every [IosTextToSpeechAudioCategory].
  kDefaultMode = 0,
  // A mode that the GameKit framework sets on behalf of an application
  // that uses GameKit’s voice chat service.
  //
  // This mode is valid only with the
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  //
  // Don’t set this mode directly. If you need similar behavior and aren’t
  // using a `GKVoiceChat` object, use [voiceChat] or [videoChat] instead.
  kGameChat = 1,
  // A mode that indicates that your app is performing measurement of audio input or output.
  //
  // Use this mode for apps that need to minimize the amount of
  // system-supplied signal processing to input and output signals.
  // If recording on devices with more than one built-in microphone,
  // the session uses the primary microphone.
  //
  // For use with the [IosTextToSpeechAudioCategory.playback] or
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  //
  // **Important:** This mode disables some dynamics processing on input and output signals,
  // resulting in a lower-output playback level.
  kMeasurement = 2,
  // A mode that indicates that your app is playing back movie content.
  //
  // When you set this mode, the audio session uses signal processing to enhance
  // movie playback for certain audio routes such as built-in speaker or headphones.
  // You may only use this mode with the
  // [IosTextToSpeechAudioCategory.playback] category.
  kMoviePlayback = 3,
  // A mode used for continuous spoken audio to pause the audio when another app plays a short audio prompt.
  //
  // This mode is appropriate for apps that play continuous spoken audio,
  // such as podcasts or audio books. Setting this mode indicates that your app
  // should pause, rather than duck, its audio if another app plays
  // a spoken audio prompt. After the interrupting app’s audio ends, you can
  // resume your app’s audio playback.
  kSpokenAudio = 4,
  // A mode that indicates that your app is engaging in online video conferencing.
  //
  // Use this mode for video chat apps that use the
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  // When you set this mode, the audio session optimizes the device’s tonal
  // equalization for voice. It also reduces the set of allowable audio routes
  // to only those appropriate for video chat.
  //
  // Using this mode has the side effect of enabling the
  // [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
  kVideoChat = 5,
  // A mode that indicates that your app is recording a movie.
  //
  // This mode is valid only with the
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  // On devices with more than one built-in microphone,
  // the audio session uses the microphone closest to the video camera.
  //
  // Use this mode to ensure that the system provides appropriate audio-signal processing.
  kVideoRecording = 6,
  // A mode that indicates that your app is performing two-way voice communication,
  // such as using Voice over Internet Protocol (VoIP).
  //
  // Use this mode for Voice over IP (VoIP) apps that use the
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  // When you set this mode, the session optimizes the device’s tonal
  // equalization for voice and reduces the set of allowable audio routes
  // to only those appropriate for voice chat.
  //
  // Using this mode has the side effect of enabling the
  // [IosTextToSpeechAudioCategoryOptions.allowBluetooth] category option.
  kVoiceChat = 7,
  // A mode that indicates that your app plays audio using text-to-speech.
  //
  // Setting this mode allows for different routing behaviors when your app
  // is connected to certain audio devices, such as CarPlay.
  // An example of an app that uses this mode is a turn-by-turn navigation app
  // that plays short prompts to the user.
  //
  // Typically, apps of the same type also configure their sessions to use the
  // [IosTextToSpeechAudioCategoryOptions.duckOthers] and
  // [IosTextToSpeechAudioCategoryOptions.interruptSpokenAudioAndMixWithOthers] options.
  kVoicePrompt = 8
};

// Audio session category options for iOS.
//
// See also:
// * https://developer.apple.com/documentation/avfaudio/avaudiosession/categoryoptions
enum class IosTextToSpeechAudioCategoryOptions {
  // An option that indicates whether audio from this session mixes with audio
  // from active sessions in other audio apps.
  //
  // You can set this option explicitly only if the audio session category
  // is [IosTextToSpeechAudioCategory.playAndRecord] or
  // [IosTextToSpeechAudioCategory.playback].
  // If you set the audio session category to [IosTextToSpeechAudioCategory.ambient],
  // the session automatically sets this option.
  // Likewise, setting the [duckOthers] or [interruptSpokenAudioAndMixWithOthers]
  // options also enables this option.
  //
  // If you set this option, your app mixes its audio with audio playing
  // in background apps, such as the Music app.
  kMixWithOthers = 0,
  // An option that reduces the volume of other audio sessions while audio
  // from this session plays.
  //
  // You can set this option only if the audio session category is
  // [IosTextToSpeechAudioCategory.playAndRecord] or
  // [IosTextToSpeechAudioCategory.playback].
  // Setting it implicitly sets the [mixWithOthers] option.
  //
  // Use this option to mix your app’s audio with that of others.
  // While your app plays its audio, the system reduces the volume of other
  // audio sessions to make yours more prominent. If your app provides
  // occasional spoken audio, such as in a turn-by-turn navigation app
  // or an exercise app, you should also set the [interruptSpokenAudioAndMixWithOthers] option.
  //
  // Note that ducking begins when you activate your app’s audio session
  // and ends when you deactivate the session.
  //
  // See also:
  // * [FlutterTts.setSharedInstance]
  kDuckOthers = 1,
  // An option that determines whether to pause spoken audio content
  // from other sessions when your app plays its audio.
  //
  // You can set this option only if the audio session category is
  // [IosTextToSpeechAudioCategory.playAndRecord] or
  // [IosTextToSpeechAudioCategory.playback].
  // Setting this option also sets [mixWithOthers].
  //
  // If you set this option, the system mixes your audio with other
  // audio sessions, but interrupts (and stops) audio sessions that use the
  // [IosTextToSpeechAudioMode.spokenAudio] audio session mode.
  // It pauses the audio from other apps as long as your session is active.
  // After your audio session deactivates, the system resumes the interrupted app’s audio.
  //
  // Set this option if your app’s audio is occasional and spoken,
  // such as in a turn-by-turn navigation app or an exercise app.
  // This avoids intelligibility problems when two spoken audio apps mix.
  // If you set this option, also set the [duckOthers] option unless
  // you have a specific reason not to. Ducking other audio, rather than
  // interrupting it, is appropriate when the other audio isn’t spoken audio.
  kInterruptSpokenAudioAndMixWithOthers = 2,
  // An option that determines whether Bluetooth hands-free devices appear
  // as available input routes.
  //
  // You can set this option only if the audio session category is
  // [IosTextToSpeechAudioCategory.playAndRecord] or
  // [IosTextToSpeechAudioCategory.playback].
  //
  // You’re required to set this option to allow routing audio input and output
  // to a paired Bluetooth Hands-Free Profile (HFP) device.
  // If you clear this option, paired Bluetooth HFP devices don’t show up
  // as available audio input routes.
  kAllowBluetooth = 3,
  // An option that determines whether you can stream audio from this session
  // to Bluetooth devices that support the Advanced Audio Distribution Profile (A2DP).
  //
  // A2DP is a stereo, output-only profile intended for higher bandwidth
  // audio use cases, such as music playback.
  // The system automatically routes to A2DP ports if you configure an
  // app’s audio session to use the [IosTextToSpeechAudioCategory.ambient],
  // [IosTextToSpeechAudioCategory.ambientSolo], or
  // [IosTextToSpeechAudioCategory.playback] categories.
  //
  // Starting with iOS 10.0, apps using the
  // [IosTextToSpeechAudioCategory.playAndRecord] category may also allow
  // routing output to paired Bluetooth A2DP devices. To enable this behavior,
  // pass this category option when setting your audio session’s category.
  //
  // Note: If this option and the [allowBluetooth] option are both set,
  // when a single device supports both the Hands-Free Profile (HFP) and A2DP,
  // the system gives hands-free ports a higher priority for routing.
  kAllowBluetoothA2DP = 4,
  // An option that determines whether you can stream audio
  // from this session to AirPlay devices.
  //
  // Setting this option enables the audio session to route audio output
  // to AirPlay devices. You can only explicitly set this option if the
  // audio session’s category is set to [IosTextToSpeechAudioCategory.playAndRecord].
  // For most other audio session categories, the system sets this option implicitly.
  kAllowAirPlay = 5,
  // An option that determines whether audio from the session defaults to the built-in speaker instead of the receiver.
  //
  // You can set this option only when using the
  // [IosTextToSpeechAudioCategory.playAndRecord] category.
  // It’s used to modify the category’s routing behavior so that audio
  // is always routed to the speaker rather than the receiver if
  // no other accessories, such as headphones, are in use.
  //
  // When using this option, the system honors user gestures.
  // For example, plugging in a headset causes the route to change to
  // headset mic/headphones, and unplugging the headset causes the route
  // to change to built-in mic/speaker (as opposed to built-in mic/receiver)
  // when you’ve set this override.
  //
  // In the case of using a USB input-only accessory, audio input
  // comes from the accessory, and the system routes audio to the headphones,
  // if attached, or to the speaker if the headphones aren’t plugged in.
  // The use case is to route audio to the speaker instead of the receiver
  // in cases where the audio would normally go to the receiver.
  kDefaultToSpeaker = 6
};

enum class TtsPlatform {
  kAndroid = 0,
  kIos = 1
};


// Generated class from Pigeon that represents data sent in messages.
class Voice {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit Voice(
    const std::string& name,
    const std::string& locale);

  // Constructs an object setting all fields.
  explicit Voice(
    const std::string& name,
    const std::string& locale,
    const std::string* gender,
    const std::string* quality,
    const std::string* identifier);

  const std::string& name() const;
  void set_name(std::string_view value_arg);

  const std::string& locale() const;
  void set_locale(std::string_view value_arg);

  const std::string* gender() const;
  void set_gender(const std::string_view* value_arg);
  void set_gender(std::string_view value_arg);

  const std::string* quality() const;
  void set_quality(const std::string_view* value_arg);
  void set_quality(std::string_view value_arg);

  const std::string* identifier() const;
  void set_identifier(const std::string_view* value_arg);
  void set_identifier(std::string_view value_arg);

 private:
  static Voice FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class TtsHostApi;
  friend class IosTtsHostApi;
  friend class AndroidTtsHostApi;
  friend class MacosTtsHostApi;
  friend class TtsFlutterApi;
  friend class PigeonInternalCodecSerializer;
  std::string name_;
  std::string locale_;
  std::optional<std::string> gender_;
  std::optional<std::string> quality_;
  std::optional<std::string> identifier_;
};


// Generated class from Pigeon that represents data sent in messages.
class TtsResult {
 public:
  // Constructs an object setting all non-nullable fields.
  explicit TtsResult(bool success);

  // Constructs an object setting all fields.
  explicit TtsResult(
    bool success,
    const std::string* message);

  bool success() const;
  void set_success(bool value_arg);

  const std::string* message() const;
  void set_message(const std::string_view* value_arg);
  void set_message(std::string_view value_arg);

 private:
  static TtsResult FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class TtsHostApi;
  friend class IosTtsHostApi;
  friend class AndroidTtsHostApi;
  friend class MacosTtsHostApi;
  friend class TtsFlutterApi;
  friend class PigeonInternalCodecSerializer;
  bool success_;
  std::optional<std::string> message_;
};


// Generated class from Pigeon that represents data sent in messages.
class TtsProgress {
 public:
  // Constructs an object setting all fields.
  explicit TtsProgress(
    const std::string& text,
    int64_t start,
    int64_t end,
    const std::string& word);

  const std::string& text() const;
  void set_text(std::string_view value_arg);

  int64_t start() const;
  void set_start(int64_t value_arg);

  int64_t end() const;
  void set_end(int64_t value_arg);

  const std::string& word() const;
  void set_word(std::string_view value_arg);

 private:
  static TtsProgress FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class TtsHostApi;
  friend class IosTtsHostApi;
  friend class AndroidTtsHostApi;
  friend class MacosTtsHostApi;
  friend class TtsFlutterApi;
  friend class PigeonInternalCodecSerializer;
  std::string text_;
  int64_t start_;
  int64_t end_;
  std::string word_;
};


// Generated class from Pigeon that represents data sent in messages.
class TtsRateValidRange {
 public:
  // Constructs an object setting all fields.
  explicit TtsRateValidRange(
    double minimum,
    double normal,
    double maximum,
    const TtsPlatform& platform);

  double minimum() const;
  void set_minimum(double value_arg);

  double normal() const;
  void set_normal(double value_arg);

  double maximum() const;
  void set_maximum(double value_arg);

  const TtsPlatform& platform() const;
  void set_platform(const TtsPlatform& value_arg);

 private:
  static TtsRateValidRange FromEncodableList(const flutter::EncodableList& list);
  flutter::EncodableList ToEncodableList() const;
  friend class TtsHostApi;
  friend class IosTtsHostApi;
  friend class AndroidTtsHostApi;
  friend class MacosTtsHostApi;
  friend class TtsFlutterApi;
  friend class PigeonInternalCodecSerializer;
  double minimum_;
  double normal_;
  double maximum_;
  TtsPlatform platform_;
};


class PigeonInternalCodecSerializer : public flutter::StandardCodecSerializer {
 public:
  PigeonInternalCodecSerializer();
  inline static PigeonInternalCodecSerializer& GetInstance() {
    static PigeonInternalCodecSerializer sInstance;
    return sInstance;
  }

  void WriteValue(
    const flutter::EncodableValue& value,
    flutter::ByteStreamWriter* stream) const override;
 protected:
  flutter::EncodableValue ReadValueOfType(
    uint8_t type,
    flutter::ByteStreamReader* stream) const override;
};

// Generated interface from Pigeon that represents a handler of messages from Flutter.
class TtsHostApi {
 public:
  TtsHostApi(const TtsHostApi&) = delete;
  TtsHostApi& operator=(const TtsHostApi&) = delete;
  virtual ~TtsHostApi() {}
  virtual void Speak(
    const std::string& text,
    bool force_focus,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void Pause(std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void Stop(std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetSpeechRate(
    double rate,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetVolume(
    double volume,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetPitch(
    double pitch,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetVoice(
    const Voice& voice,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void ClearVoice(std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void AwaitSpeakCompletion(
    bool await_completion,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void GetLanguages(std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;
  virtual void GetVoices(std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;

  // The codec used by TtsHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `TtsHostApi` to handle messages through the `binary_messenger`.
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    TtsHostApi* api);
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    TtsHostApi* api,
    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);
 protected:
  TtsHostApi() = default;
};
// Generated interface from Pigeon that represents a handler of messages from Flutter.
class IosTtsHostApi {
 public:
  IosTtsHostApi(const IosTtsHostApi&) = delete;
  IosTtsHostApi& operator=(const IosTtsHostApi&) = delete;
  virtual ~IosTtsHostApi() {}
  virtual void AwaitSynthCompletion(
    bool await_completion,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SynthesizeToFile(
    const std::string& text,
    const std::string& file_name,
    bool is_full_path,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetSharedInstance(
    bool shared_session,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void AutoStopSharedSession(
    bool auto_stop,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetIosAudioCategory(
    const IosTextToSpeechAudioCategory& category,
    const flutter::EncodableList& options,
    const IosTextToSpeechAudioMode& mode,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void GetSpeechRateValidRange(std::function<void(ErrorOr<TtsRateValidRange> reply)> result) = 0;
  virtual void IsLanguageAvailable(
    const std::string& language,
    std::function<void(ErrorOr<bool> reply)> result) = 0;
  virtual void SetLanguange(
    const std::string& language,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;

  // The codec used by IosTtsHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `IosTtsHostApi` to handle messages through the `binary_messenger`.
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    IosTtsHostApi* api);
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    IosTtsHostApi* api,
    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);
 protected:
  IosTtsHostApi() = default;
};
// Generated interface from Pigeon that represents a handler of messages from Flutter.
class AndroidTtsHostApi {
 public:
  AndroidTtsHostApi(const AndroidTtsHostApi&) = delete;
  AndroidTtsHostApi& operator=(const AndroidTtsHostApi&) = delete;
  virtual ~AndroidTtsHostApi() {}
  virtual void AwaitSynthCompletion(
    bool await_completion,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void GetMaxSpeechInputLength(std::function<void(ErrorOr<std::optional<int64_t>> reply)> result) = 0;
  virtual void SetEngine(
    const std::string& engine,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void GetEngines(std::function<void(ErrorOr<flutter::EncodableList> reply)> result) = 0;
  virtual void GetDefaultEngine(std::function<void(ErrorOr<std::optional<std::string>> reply)> result) = 0;
  virtual void GetDefaultVoice(std::function<void(ErrorOr<std::optional<Voice>> reply)> result) = 0;
  // [Future] which invokes the platform specific method for synthesizeToFile
  virtual void SynthesizeToFile(
    const std::string& text,
    const std::string& file_name,
    bool is_full_path,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void IsLanguageInstalled(
    const std::string& language,
    std::function<void(ErrorOr<bool> reply)> result) = 0;
  virtual void IsLanguageAvailable(
    const std::string& language,
    std::function<void(ErrorOr<bool> reply)> result) = 0;
  virtual void AreLanguagesInstalled(
    const flutter::EncodableList& languages,
    std::function<void(ErrorOr<flutter::EncodableMap> reply)> result) = 0;
  virtual void GetSpeechRateValidRange(std::function<void(ErrorOr<TtsRateValidRange> reply)> result) = 0;
  virtual void SetSilence(
    int64_t timems,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetQueueMode(
    int64_t queue_mode,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void SetAudioAttributesForNavigation(std::function<void(ErrorOr<TtsResult> reply)> result) = 0;

  // The codec used by AndroidTtsHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `AndroidTtsHostApi` to handle messages through the `binary_messenger`.
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    AndroidTtsHostApi* api);
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    AndroidTtsHostApi* api,
    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);
 protected:
  AndroidTtsHostApi() = default;
};
// Generated interface from Pigeon that represents a handler of messages from Flutter.
class MacosTtsHostApi {
 public:
  MacosTtsHostApi(const MacosTtsHostApi&) = delete;
  MacosTtsHostApi& operator=(const MacosTtsHostApi&) = delete;
  virtual ~MacosTtsHostApi() {}
  virtual void AwaitSynthCompletion(
    bool await_completion,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void GetSpeechRateValidRange(std::function<void(ErrorOr<TtsRateValidRange> reply)> result) = 0;
  virtual void SetLanguange(
    const std::string& language,
    std::function<void(ErrorOr<TtsResult> reply)> result) = 0;
  virtual void IsLanguageAvailable(
    const std::string& language,
    std::function<void(ErrorOr<bool> reply)> result) = 0;

  // The codec used by MacosTtsHostApi.
  static const flutter::StandardMessageCodec& GetCodec();
  // Sets up an instance of `MacosTtsHostApi` to handle messages through the `binary_messenger`.
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    MacosTtsHostApi* api);
  static void SetUp(
    flutter::BinaryMessenger* binary_messenger,
    MacosTtsHostApi* api,
    const std::string& message_channel_suffix);
  static flutter::EncodableValue WrapError(std::string_view error_message);
  static flutter::EncodableValue WrapError(const FlutterError& error);
 protected:
  MacosTtsHostApi() = default;
};
// Generated class from Pigeon that represents Flutter messages that can be called from C++.
class TtsFlutterApi {
 public:
  TtsFlutterApi(flutter::BinaryMessenger* binary_messenger);
  TtsFlutterApi(
    flutter::BinaryMessenger* binary_messenger,
    const std::string& message_channel_suffix);
  static const flutter::StandardMessageCodec& GetCodec();
  void OnSpeakStartCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakCompleteCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakPauseCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakResumeCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakCancelCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakProgressCb(
    const TtsProgress& progress,
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSpeakErrorCb(
    const std::string& error,
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSynthStartCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSynthCompleteCb(
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
  void OnSynthErrorCb(
    const std::string& error,
    std::function<void(void)>&& on_success,
    std::function<void(const FlutterError&)>&& on_error);
 private:
  flutter::BinaryMessenger* binary_messenger_;
  std::string message_channel_suffix_;
};

}  // namespace flutter_tts
#endif  // PIGEON_MESSAGES_G_H_
